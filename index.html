from flask import Flask, request, jsonify
from flask_cors import CORS
import telebot
from telebot.types import ReplyKeyboardMarkup, KeyboardButton, WebAppInfo, InlineKeyboardMarkup, InlineKeyboardButton
from uuid import uuid4
from io import BytesIO

app = Flask(__name__)
CORS(app)

BOT_TOKEN = '8135740899:AAHzRcsdGJhcoDiim0UZEN1zFtDHmkhza1c'  # –¢–≤–æ–π —Ç–æ–∫–µ–Ω
CHAT_ID = '-4966315080'  # –¢–≤–æ–π chat_id (–≥—Ä—É–ø–ø–∞ –∏–ª–∏ —á–∞—Ç)
bot = telebot.TeleBot(BOT_TOKEN)

MINIAPP_URL = "https://tomasdiada.github.io/delivery-miniapp/"

# –•—Ä–∞–Ω–∏–ª–∏—â–µ –∑–∞–∫–∞–∑–æ–≤: order_id -> –¥–∞–Ω–Ω—ã–µ
orders = {}

@app.route('/api/order', methods=['POST'])
def handle_order():
    phone = request.form.get('phone')
    latitude = request.form.get('latitude')
    longitude = request.form.get('longitude')
    photo = request.files.get('photo')

    if not all([phone, latitude, longitude, photo]):
        return "Missing data", 400

    order_id = str(uuid4())[:8]
    photo_bytes = photo.read()
    photo_io = BytesIO(photo_bytes)
    photo_io.name = photo.filename

    orders[order_id] = {
        'phone': phone,
        'latitude': latitude,
        'longitude': longitude,
        'photo': photo_bytes,
        'status': '–ù–æ–≤—ã–π'
    }

    maps_url = f"https://yandex.ru/maps/?ll={longitude},{latitude}&z=16&pt={longitude},{latitude},pm2rdm"
    message_text = (
        f"üì¶ –ù–æ–≤—ã–π –∑–∞–∫–∞–∑ #{order_id}!\n"
        f"üì± –¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n"
        f"üìç –ì–µ–æ–ø–æ–∑–∏—Ü–∏—è: [–û—Ç–∫—Ä—ã—Ç—å –≤ –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç–∞—Ö]({maps_url})\n"
        f"–°—Ç–∞—Ç—É—Å: –ù–æ–≤—ã–π"
    )

    markup = InlineKeyboardMarkup()
    markup.add(
        InlineKeyboardButton("–ü—Ä–∏–Ω—è—Ç", callback_data=f"{order_id}|–ü—Ä–∏–Ω—è—Ç"),
        InlineKeyboardButton("–í —Ä–∞–±–æ—Ç–µ", callback_data=f"{order_id}|–í —Ä–∞–±–æ—Ç–µ"),
        InlineKeyboardButton("–í—ã–ø–æ–ª–Ω–µ–Ω", callback_data=f"{order_id}|–í—ã–ø–æ–ª–Ω–µ–Ω"),
    )

    try:
        bot.send_message(CHAT_ID, message_text, reply_markup=markup, parse_mode='Markdown')
        bot.send_photo(CHAT_ID, photo_io)
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–ª–∏ —Ñ–æ—Ç–æ: {e}")

    return jsonify({'status': 'ok', 'order_id': order_id})

@bot.callback_query_handler(func=lambda call: True)
def callback_handler(call):
    order_id, new_status = call.data.split('|')
    order = orders.get(order_id)

    if not order:
        bot.answer_callback_query(call.id, "–ó–∞–∫–∞–∑ –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return

    user = call.from_user
    username_display = user.username or f"{user.first_name or ''} {user.last_name or ''}".strip()
    user_id = user.id

    if 'status_users' not in order:
        order['status_users'] = {}

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º username –∏ user_id –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞
    order['status_users'][new_status] = (username_display, user_id)

    maps_url = f"https://yandex.ru/maps/?ll={order['longitude']},{order['latitude']}&z=16&pt={order['longitude']},{order['latitude']},pm2rdm"

    status_texts = {
        '–ü—Ä–∏–Ω—è—Ç': '‚úÖ –ü—Ä–∏–Ω—è—Ç',
        '–í —Ä–∞–±–æ—Ç–µ': 'üîß –í —Ä–∞–±–æ—Ç–µ',
        '–í—ã–ø–æ–ª–Ω–µ–Ω': '‚úîÔ∏è –í—ã–ø–æ–ª–Ω–µ–Ω'
    }

    status_lines = []
    for status_key in ['–ü—Ä–∏–Ω—è—Ç', '–í —Ä–∞–±–æ—Ç–µ', '–í—ã–ø–æ–ª–Ω–µ–Ω']:
        user_data = order['status_users'].get(status_key)
        if user_data:
            name, uid = user_data
            # –°–æ–∑–¥–∞—ë–º —Å—Å—ã–ª–∫—É –Ω–∞ –ø—Ä–æ—Ñ–∏–ª—å
            clickable_name = f"[{name}](tg://user?id={uid})"
            status_lines.append(f"{status_texts[status_key]}: {clickable_name}")

    statuses_info = '\n'.join(status_lines) if status_lines else "–°—Ç–∞—Ç—É—Å –ø–æ–∫–∞ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω."

    new_text = (
        f"üì¶ –ó–∞–∫–∞–∑ #{order_id}\n"
        f"üì± –¢–µ–ª–µ—Ñ–æ–Ω: {order['phone']}\n"
        f"üìç –ì–µ–æ–ø–æ–∑–∏—Ü–∏—è: [–û—Ç–∫—Ä—ã—Ç—å –≤ –Ø–Ω–¥–µ–∫—Å.–ö–∞—Ä—Ç–∞—Ö]({maps_url})\n\n"
        f"{statuses_info}"
    )

    bot.edit_message_text(
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        text=new_text,
        reply_markup=call.message.reply_markup,
        parse_mode='Markdown'
    )

    bot.answer_callback_query(call.id, f"–°—Ç–∞—Ç—É—Å ¬´{new_status}¬ª —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º {username_display}")




@bot.message_handler(commands=['start'])
def start_message(message):
    markup = ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
    web_app = WebAppInfo(url=MINIAPP_URL)
    button = KeyboardButton(text="–û—Ç–∫—Ä—ã—Ç—å –∑–∞–∫–∞–∑", web_app=web_app)
    markup.add(button)
    bot.send_message(message.chat.id, "–ü—Ä–∏–≤–µ—Ç! –ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å —Ñ–æ—Ä–º—É –∑–∞–∫–∞–∑–∞:", reply_markup=markup)

@app.route(f'/{BOT_TOKEN}', methods=['POST'])
def telegram_webhook():
    json_string = request.get_data().decode('utf-8')
    update = telebot.types.Update.de_json(json_string)
    bot.process_new_updates([update])
    return '', 200

if __name__ == '__main__':
    NGROK_URL = 'https://13ba-5-35-38-182.ngrok-free.app'
    bot.remove_webhook()
    bot.set_webhook(url=NGROK_URL + '/' + BOT_TOKEN)

    app.run(host='0.0.0.0', port=5000)
